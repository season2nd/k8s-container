docker의 명령어 옵션들

commit : 새로운 이미지(내가 만들 컨테이너)를 만들때 사용하는 옵션 입니다.
exec  : 내가 실행한 컨테이너 안에 들어 갈수 있는 옵션입니다.
    Run a command in a running container

hub.docker.com 을 private cloud 처럼 (image)....

백업:
쿠버네티스 : configuration파일(json), yaml(절차서)..파일위주 백업,  etcd
도커 : 이미지 ( 우리가 만든 image)


#docker run -d -it --name web nginx
#docker exec -it web /bin/bash
#curl 172.17.0.2 실행하시면 컨테이너의 index.html을 읽어서 보여줍니다.
#echo "Test web" > index.html

docker images prune은 실제 사용하지 않는 이미지를 삭제 합니다 
docker container prune은 https://wikidocs.net/110954
docker ps -a해서 보여지는 garbage process를 삭제 할수 있습니다 


SaaS : software
IaaS : Infra
PaaS : Platform  (쿠버네티스) 

도커: swarm (멀티 컨테이너 운영시 사용 가능)
미니쿠버 : 적은 사이즈(컨테이너 갯수, 쿠버의 서비스)의 쿠버네티스 

https://kubernetes.io/docs/setup/production-environment/container-runtimes/
----------------------------------------------------------------------------------------------
쿠버네티스 설치 순서
https://kubernetes.io/ko/docs/setup/production-environment/tools/kubeadm/install-kubeadm/

1. 스왑의 비활성화. kubelet이 제대로 작동하게 하려면 반드시 스왑을 사용하지 않도록 설정한다

swapoff -a && sed -i '/swap/s/^/#/' /etc/fstab

2. iptables가 브리지된 트래픽을 보게 하기

cat <<EOF | sudo tee /etc/modules-load.d/k8s.conf
br_netfilter
EOF

cat <<EOF | sudo tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
EOF
sudo sysctl --system

3.  Disable firewall
systemctl stop firewalld 
systemctl disable firewalld

4. kubeadm, kubelet 및 kubectl 설치
cat <<EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
exclude=kubelet kubeadm kubectl
EOF

# permissive 모드로 SELinux 설정(효과적으로 비활성화)
sudo setenforce 0
sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config

sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes

sudo systemctl enable --now kubelet

--------------------------------------------------------------------------------
1. 쿠버네티스 master node에 마스터 컴포넌트들을 설치해야 합니다
설치 마지막에 토큰키가 생성 됩니다. ( 꼭 저장을 해 놓습니다 notepad)
1-1.kubeadm init 이라는 명령어를 실행 합니다 

1-2. Creating a cluster with kubeadm
https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/

mkdir -p $HOME/.kube
sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
sudo chown $(id -u):$(id -g) $HOME/.kube/config


2. CNI (컨테이너 네트워크 인터페이스) 설치해야 합니다 
플라넷, 위브넷, 칼리코 ( VxLAN, overlay,...)

https://www.weave.works/docs/net/latest/kubernetes/kube-addon/#install

$ kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"

kubectl get nodes  
명령어 실행시 master node가 보여줘야 합니다.

3.  1번에서 생성된 토큰키를 클라이언(node 서버에 가서 해당 토큰 명령어) 실행시켜 줍니다. 

토큰 생성 시간은 24시간만 생성 되어있습니다.
새로운 node를 추가해야 될 경우 토큰 새로 생성 해줘야 합니다 
토큰 생성 시간은 옵션을 통해서 조정 가능합니다.

아래는 예시입니다 
kubeadm join 10.100.0.104:6443 --token sjfkjskdkskfks.....
-discovery-token-ca-cert/......jsljfkskfdksfjkwsjk

실행이 되어야 합니다 
하지만 에러가 발생하거나 kubectl get nodes를 못가져 올수 있습니다 .

kubeadm join 10.100.0.104:6443 --token eif8yt.1g5v9bmof0cl8hc4 \
	--discovery-token-ca-cert-hash sha256:1fa5059aa47b2af05674bcae160d8344b145e381b1195de74ca0780b3da987da 

도커설치시에 도커 끼리 communication 문제시에 아래 작업을 해줍니다 .

classroom 안에서 클라이언트들이 TLS 인증 없이 docker 데몬에 access할 수 있도록
daemon.json 파일을 수정한다.
# dockerd --help
# vim /etc/docker/daemon.json
{
"insecure-registries": ["10.100.0.0/24"]
}

서비스 데몬 실행
# systemctl restart docker

-----------------------------------------------------------------------------------------------
master node
API : 지휘자 
controller : 조정하는 사람
scheduler : 예약 하는 사람 
etcd : DB

신논현에다가 치킨.... 장사 .... 프랜차이즈를 하자.

사장 -> 부사장 > 임원 > 감사 매니저.... 직원 등등을 고용합니다.

브랜치 ( 강남구, 서초구, 종로구 등등....) ( 매니저와 직원들) 

본사에서 관리를 합니다.
정책,, 명령이나... 내려옵니다. 그일을 전달하는 사람은 매니저 그일을 하는 사람은 직원,,,

API server: 부사장 ... 각각 브런치에다가 그 명령을 하달하는 역할을 합니다.(매니저)
controller :  각 지역의 통일된 보안이나 서비스 정책을 감시하는 역할을 합니다.
scheduller : 각 지역의 분포도를 파악하고 적절하게 어떤 지역에 분배를 할지 결정합니다.
etcd : API 서버가 활용할 핵심 데이터 저장공간 ( 각 노드들의 정보, 서비스 상태 등등)
쿠버네티스 백업시에 가장 우선시 해야될 부분입니다.

하둡, 클라우드, 파이썬 등에서 많이 사용합니다

(key:value) 사전 
딕셔너리 = { 키: 값 }

a(삭제 불가, 변경불가) : about, above, alone(삭제 가능, 변경가능) 
예 를 들어서 about이라는 단어를 찾기 위해서는 a는 알파벳을 먼저 서치를 합니다 

워크노드
kubelet : 본사의 정책들을 확인해서 각 매장의 매니저들에게 전달해주는 역할을 담당
kube-proxy: 예상 되는 고객들의 수요를 적절한 곳을 안내하고 매니징 하는 역활
pod: 매장을 총괄하는 실제 매니저 

주의 : 컨테이너, pod,워크노드 다 다른 의미 입니다.

-----------------------------------------------------------------------------
API : k8s API를 사용하도록 요청을 받고 요청이 유효한지 검사
Schedule : 파드를 실행할 노드를 선택
controller: 파드를 관찰하며 개수를 보장
etcd: key:value로 구성되어있는 저장소 
(workd node들의 상태정보, 컨테이너 동작 중인 상태... 등등)

kube-proxy :k8s의 n/w 동작을 관리(iptable rule을 구성)

add-on : cAdviser(kubelet), coreDNS( dns add-on : 컨테이너와 컨테이너의 n/w를 연결)

마스터 : CNI, 대쉬보드(webUI)

logging관련 관리는

ELK (ElasticSearch (필요한 로그를 정재해줌), logstash( 각노드의 실행중인 애플리케이션 수집), kibana(Web UI대쉬보드 제공)
EFK (flunted)
Datadog
-------------------------------------------------------------------------------------------

# kubectl api-resources 

# kubectl explain <서비스 이름>
예시) # kubectl explain pods

KIND:     Pod
VERSION:  v1
두가지를 통해서 yaml(스크립트파일)을 만들때 사용합니다.

#kubectl describe node master.example.com 
#kubectl run webserver --image=nginx:1.14 --port 80
#kubectl get pods
#kubectl run webserver1 --image=nginx --port 80
#kubectl describe pod webserver

Events:
  Type    Reason     Age    From               Message
  ----    ------     ----   ----               -------
  Normal  Scheduled  4m47s  default-scheduler  Successfully assigned default/webserver to node2.example.com
  
Normal  Pulling    4m47s  kubelet            Pulling image "nginx:1.14"
  Normal  Pulled     4m38s  kubelet            Successfully pulled

 image "nginx:1.14" in 9.095011037s
  Normal  Created    4m38s  kubelet            Created container webserver

  Normal  Started    4m38s  kubelet            Started container webserver

pod 실행후 실제 잘 돌아가는지 먼저 확인 합니다
kubectl get pods를 통해서 체크 
이후에 status가 running이 아니라면

#watch kubectl get pods -o wide

kubectl describe pod webserver<pod 이름>
으로 맨마지막 로그를 체크 합니다.

#kubectl exec webserver -it -- /bin/bash
를 통해서 pod에 들어갑니다


#echo "Test Web" > index.html
#cat index.html
Test Web

curl <pod ip addr> 로 host에서 확인 합니다 

#kubectl delete pod webserver 로 pod를 삭제 합니다 

#kubectl get pod webserver1 -o json

#kubectl get pod webserver1 -o yaml

kubectl create는 yaml파일을 실행시에 사용 합니다 
create와 apply는 이 있습니다.

#kubectl run webserver --image=nginx:1.14 --port 80 --dry-run

--dry-run: 실행이 잘되는지 확인해주는 옵션 입니다.


# kubectl run webserver --image=nginx:1.14 --port 80 --dry-run -o yaml

apiVersion: v1
kind: Pod
metadata:
  name: webserver
spec:
  containers:
  - image: nginx:1.14
    name: webserver
    ports:
    - containerPort: 80

# kubectl run webserver --image=nginx:1.14 --port 80 --dry-run -o yaml > webserver-pod.yaml


# kubectl create -f webserver-pod.yaml 
pod/webserver created

실습 
해당 pod의 ip addr와 파드 생성 로그를 확인해보세요 

에어컨 : 내가 원하는 온도 : 28 
현재 온도는 : 31 도

31- > 30 -> 29 -> 28 내가 원하는 온도를 하나씩 하나씩 변경 됩니다.

예를 들어서 50대 nginx가 설치 된 환경에서는 
하나씩 하나씩 변경 됩니다. 

------------------------------------------------------------------------
yaml 에 대해서 
https://yaml.org/
 공식 사이트 

1. python처럼 들여쓰기로 데이타 계층을 표기 합니다 
     가급적 tab키가 아니라 space bar 사용해서 2, 4칸을 들여쓰기 합니다.

2. scalar 문법 :  ':' 을 기준으로 key: value  를 설정합니다 

3. 배열 : '-' 문자로 여러개를 나열 합니다.


내일 : 토큰 , 일반사용자 guru가 kubectl명령어를 쓸수 있게 세팅하는법






